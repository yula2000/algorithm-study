#N장의 카드 -> 차례로 1부터 N까지의 번호가 붙어 있어서 1번 카드가 제일 위에, N번 카드가 제일 아래인 상태로 순서대로 카드가 높여 있다. 
# 제일 위에 있는 카드를 바닥에 버리고, 그 다음 제일 위에 있는 카드를 제일 아래에 있는 카드 밑으로 옮긴다. 
# N = 4인 경우 카드는 제일 위에서부터 1234의 순서로 놓여있다. 
# 1을 버리면 234가 남고, 여기서 2를 제일 아래로 옮기면 342가 됨. 

from collections import deque ##

N = int(input())  #N장의 카드가 있으면 
cards = deque(range(1,N+1))  ##카드담을곳
while len(cards) > 1: ##카드 한장 남을떄까지
    cards.popleft() ##맨 위 카드 버리겠음

    if cards:  ##만약 카드가 
        top_card = cards.popleft()  ##맨위 한장 버린걸 top_card에 저장했다가
        cards.append(top_card)  ##cards에 추가한다. 

print(cards[0])


# N=int(input())
# arr = []
# for n in range(1,N+1): #1번부터 N번카드까지 순서대로 있음 그걸 꺼내겠음 위부터
#     arr.append(n) #하나씩 꺼내 넣어서
#     arr.sort() #정렬하겠음

#     if n % 2 != 0 :  #보아하니 홀수만 버려지는듯
#         arr.pop(n) #n은 커지는 숫자 리스트범위를 벗어나게 될지도 
#     elif n %2 == 0 :#짝수면 
#         arr.append(pop(n)) #그걸 빼가지고 뒤에 넣는다. 

#     if len(arr) == 1:
#         print(n)
#SWEA 13일 큐 11623
T = int(input())
 
for t in range(1, T+1):  #입력받았던 T를 1부터 T까지 하나씩 빼서 
    N = int(input()) #입력받은N 
     
    if N == 1:  # 만약에 N이 1이라면 
        answer = 1 #답은 1이라면 
    else:
        k= 1 #
        while k * 2 <= N: #길이가 N보다 작을떄 
            k *= 2 #2배를 한다. 
        if N == k: #같을떄 
            answer = N # N을 출력한다. 
        else:
            answer = (N - k) * 2 #
    print(f"#{t} {answer}")


    ### 큐 카드 2 문제 수학적 규칙으로 풀이하기

T = int(input())
for t in range(1, T+1):
    N = int(input())
    if N == 1:  # N이 1 인경우에는 예외가 없다 그러므로 1 (규칙성있는 수열에서 빠지기) 
        answer = 1
    else:
        k= 1
        while k * 2 <= N:
            k *= 2
        if N == k:
            answer = N 
        else:
            answer = (N - k) * 2
    print(f"#{t} {answer}")

k 는 '현재 인원수(N) 보다 작거나 같으면서 가장 큰 2의 거듭제곱 수' 이다. 
즉 게임의 규칙이 초기화 되는 기준점이다. 
 만약 기준점에 맞게 된다면 N 이 답이 되게 되고 
아니라면 (N-k)*2 가 되게 된다 . 

[N = 4 ~ 8까지 작동 과정]
핵심 규칙: k는 $N$보다 작거나 같은 가장 큰 2의 거듭제곱입니다. 
이 k를 기준으로 $N$이 얼마나 커졌느냐($N-k$)에 따라 생존자 번호가 결정됩니다.

1. N = 4 (기준점 k = 4)
k 찾기: $1 \to 2 \to 4$ (8은 4보다 크므로 $k=4$에서 멈춤)
상태: $N$이 정확히 2의 거듭제곱($k$)인 경우입니다.
계산: if N == k: 조건에 걸려 answer = 4가 됩니다.
의미: 인원이 2의 거듭제곱이면 마지막 번호(또는 1번)가 생존합니다.

2. N = 5 (기준점 k = 4)
k 찾기: $k=4$차이 
계산 ($N-k$): $5 - 4 = \mathbf{1}$ (기준보다 1명 많음)
계산: answer = 1 * 2 = 2의미: 1명이 제거되는 순간, 남은 4명 중 다음 차례인 2번이 새로운 시작점

3. N = 6 (기준점 k = 4)
k 찾기: $k=4$차이 
계산 ($N-k$): $6 - 4 = \mathbf{2}$ (기준보다 2명 많음)
계산: answer = 2 * 2 = 4
의미: 2명이 제거되는 순간, 남은 4명 중 다음 차례인 4번이 새로운 시작점

4. N = 7 (기준점 k = 4)
k 찾기: $k=4$차이 
계산 ($N-k$): $7 - 4 = \mathbf{3}$ (기준보다 3명 많음)
계산: answer = 3 * 2 = 6
의미: 3명이 제거되는 순간, 남은 4명 중 다음 차례인 6번이 새로운 시작점

5. N = 8 (새로운 기준점 k = 8)
k 찾기: $1 \to 2 \to 4 \to 8$ (16은 8보다 크므로 $k=8$에서 멈춤)
상태: 다시 $N$이 정확히 2의 거듭제곱($k$).
계산: if N == k: 조건에 걸려 answer = 8
의미: 다시 기준점이 8로 갱신되면서 규칙이 초기화

:bulb: 요약하자면
k의 의미: "가장 최근에 규칙이 1번(혹은 N번)으로 돌아갔던 인원수"
N - k의 의미: "기준점보다 추가된 인원수" → 이 인원만큼 순서가 2칸씩 뒤로 밀림.
k = 1로 시작하는 이유: 2의 거듭제곱($2, 4, 8, 16 \dots$)을 1부터 차례대로 곱해가며 $N$ 바로 직전의 기준점을 찾기 위함

이거는 수열의 N 을 늘려가며 테스트 해보면 보이는 수열의 규칙이다. 
while k * 2 <= N: k *= 2: $k$에 계속 2를 곱해가며 $N$을 넘지 않는 최대의 $2^n$ 값을 찾아내기N 이 4일때 부터 8일때까지 비교해보면 

# N = 7 일 때
k = 1
while k * 2 <= 7: # 1*2, 2*2 까지는 실행되지만 4*2는 7보다 크므로 멈춤
    k *= 2        # k는 결국 4가 됨
