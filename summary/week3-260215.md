# 📅 3주차

**일시:** 2026/02/15/일

**참석자:**
🌐 : 강현지, 김수진, 김수빈, 박성은, 정시영, 홍유라

<img src ="/summary/pics/week3.png" >

<br/>

## 🎯 이번 주 도전 문제 

**문제**
    <img src='https://static.solved.ac/tier_small/9.svg' height='20px'/> [# 1874 스택 수열](https://www.acmicpc.net/problem/1874)<br/>

**핵심 접근 및 토의 내용** 
- **방식 1: `while`문, `stack` 활용** <br/>
    - `while`문 조건 : `target number` >= `cur number` -> 목표 숫자와 같아질 때까지 push
    - 스택의 맨 위 요소(`stack[-1]`)가 목표 숫자(`target number`)면 `stack.pop()`
    - 스택 수열의 생성 가능 여부를 저장하는 플래그를 기준으로 연산자/`NO`출력

**풀이**
| 강현지 | 김수빈 | 김수진 | 박성은 | 정시영 | 홍유라 |
| :-: | :-: | :-: | :-: | :-: | :-: |
|[풀이.py](/hyunjeekang/BOJ/1874.py)|[풀이.py](/subeenKim/BOJ/1874.py)| - |[풀이.py](/bada0310/BOJ/1874_2주차도전문제.py)|[풀이.py](/jeongsiyeong/SWEA/1874.py)| - |

<br/>

## ❓질문 및 문제 풀이 공유

### 1. [BOJ 13023 ABCDE](https://www.acmicpc.net/problem/13023) (강현지)

- **주제:** 풀이 설명
- **내용:** 양방향 그래프를 인접리스트로 저장하기, 그래프의 모든 정점을 시작점으로 잡고 DFS 탐색, 재귀 호출의 기저 조건, 가지치기 조건

### 2. [백트래킹 유형별 코드 정리](https://github.com/hyunjeekang/til/blob/master/algorithm/permutations-and-combinations.md) (김수빈)

- **주제:** 부분집합과 조합, 순열 유형별 코드 학습
- **내용:** 중복 불가능한 순열은 visited로 체크하면서 하기! 조합은 작은 값부터 하나씩 선택하기 때문에 선택한 값보다 큰 값들 중에만 탐색하기!

### 3. [BOJ 1182 부분수열의 합](https://www.acmicpc.net/problem/1182) (정시영)

- **주제:** 새로운 풀이 설명
- **내용:** 기존 DFS 방식의 풀이가 아닌 비트마스킹을 활용! 모든 경우의 수를 이진수로 표현한 뒤 한칸씩 왼쪽으로 민 값과 비교하여 부분 수열의 합을 구한 뒤 목표값과 같을때마다 세기!

### 4. [SWEA 11315 오목판정](https://swexpertacademy.com/main/talk/solvingClub/problemView.do?solveclubId=AZvUadda80zHBIQE&contestProbId=AXaSUPYqPYMDFASQ&probBoxId=AZwmLc5K4KXHBIT3&type=PROBLEM&problemBoxTitle=%EC%B6%94%EA%B0%80_%EB%AC%B8%EC%A0%9C3&problemBoxCnt=6) (김수진)

- **주제:** Delta 문제의 풀이 조언 (found 변수의 필요성)
- **내용:** `found` 변수는 반복문의 흐름을 제어하고 결과를 안전하게 출력하기 위한 **깃발(Flag)** 역할! 

### 4. [BOJ 1158 요세푸스 문제](https://www.acmicpc.net/problem/1158) (박성은)

`deque` 를 이용한 요세푸스

- **주제:** `deque` 와 `list` 를 활용한 요세푸스 문제 요점 이해하기
- **내용:** 
요세푸스 문제의 요점은 약 3가지로 볼수 있다.
1. 원형 queue 이다.
2. 'k'번쨰의 사람을 제거한다 
('k' 번째의 위치한 '원소'를 제거하는 과정을 N-1 번 반복한다.)
3. 제거된 사람이 이후로 K 번째를 자른다.

<details>
  <summary>상세 설명</summary>
  이 문제를 푸는 방법은 list 와 deque 가 있는데 <br/>
    이때, deque 로 푸는 것이 더 효율적이다 .<br/>
    이유는 2,3 번의 과정에서  원형 큐이기 때문에<br/>
    삽입(insert) 와 삭제(delete, eliminate) 의 과정이 자주 반복된다.<br/>
    따라서 데이터의 삽입/삭제의 시간복잡도가 >> O(1) 인 que 가 더 적합하다. <br/>
    ->시물레이션 함수에 적합!<br/><br/>
    list 를 활용한 요세푸스는 O(N^2) 의 시간복잡도를 띄므로<br/>
    수학적으로 몇번째 인덱스를 지울지 계산해야한다.<br/><br/>
    핵심 원리: <br/>
    나머지 연산(%) 을 사용하여 리스트의에 끝에 도달하면, 다시 돌아오게 만드는 방식이다.<br/>
    [제거할 idx] = [현재위치 idx + k-1] <br/>
    (k-1 이 되는 이유는 인덱스의 시작이 1이 아니라 0에서부터 시작하기 때문이다.) <br/>
    e.g) N = 7 K = 3 (전체길이 1~N, 삭제할 idx  3) <br/>
    (0 +3-1)%7 = 2 (인덱스 2 에 위치한 숫자 '3' 을 제거)  <br/><br/>
    길이가 줄어들면서 알아서 당겨진다. <br/>
    (2 + 3-1) %7  =4 (idx =4 에 위치한 숫자 '5'를 제거 ) <br/>
    ->list.pop() 을 사용하더라도 O(N) 이 소요가 된다. <br/>
 
</details>

<br/>

## 📌 다음 스터디

- **다음 주 도전 문제:** <img src='https://static.solved.ac/tier_small/7.svg' height='20px'/> [#2164 카드2](https://www.acmicpc.net/problem/2164)
- **공지사항:** 2/22(일) 13:00 오프라인 스터디 예정

<br/>
