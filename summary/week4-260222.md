# 📅 4주차

**일시:** 2026/02/22/일

**참석자:**
🌐 : 강현지, 김수진, 김수빈, 박성은, 정시영, 홍유라

<br/>

## 🎯 이번 주 도전 문제 

**문제**
    <img src='https://static.solved.ac/tier_small/7.svg' height='20px'/> [# 2164 카드 2](https://www.acmicpc.net/problem/2164)<br/>

**핵심 접근 및 토의 내용** 
- 큐에 카드가 한 장 남을 때까지 반복
  - 가장 위에 있는 카드 버리기
  - 카드를 버린 후 한 장만 남았다면 바로 종료
  - 가장 위에 있는 카드 아래로 옮기기 

**풀이**
| 강현지 | 김수빈 | 김수진 | 박성은 | 정시영 | 홍유라 |
| :-: | :-: | :-: | :-: | :-: | :-: |
|[풀이.py](/hyunjeekang/BOJ/2164.py)|[풀이.py](/subeenKim/BOJ/2164.py)| [풀이.py](/sujinKim/BOJ/2164.py) |[풀이.py](/bada0310/BOJ/2164)|[풀이.py](/jeongsiyeong/BOJ/2164_card2.py)| [풀이.py](/yulahong/BOJ/2164.py) |

<br/>

## ❓질문 및 문제 풀이 공유

### 1. [CTR 정수 사각형 차이의 최소2](https://www.codetree.ai/ko/trails/complete/curated-cards/challenge-minimum-difference-on-the-integer-grid-2/description) (김수빈)

- **주제:** 풀이 설명 및 DP 풀이 방식 탐구
- **내용:** 현재 푼 방식은 가능한 최적해를 전부 저장하며 최솟값을 찾아내는 메모이제이션 방식. DP는 더 효율적인 방식을 추구하는 알고리즘이므로 최솟값을 고정시킨 상태에서 경로를 따라가며 최댓값의 최솟값을 찾아내는 식으로 코드를 짤 수 있음.

### 2. 재귀함수 (김수진)

- **주제:** 재귀함수 이해
- **내용:** 재귀함수에서 스택과 재귀의 관계성과 순서 대해서 의문이었는데 컴퓨터의 시스템과 연관지어 설명을 들음. 어떠한 일을 할때 스택에 쌓아두고 return하는 순서에서 이미 다 끝난일을 넘기고 print()하는 식으로 이해함. 즉, fun(x) /if x=0 return / print(x) /func(x-1)/print(x) 이런식으로 있다면 처음에 func(3)을 불러온다. 그러면 0이 아니기 떄문에 func(3)을 쌓아두고 ,func(2) func(1) 하다가 func(0)에서는 x=0이라서 return 한다. 그러면 맨 위의 func(0)이 없어지고 func(1)이 출력,print(2)가 출력, print(3)이 출력 이런식으로 하면 print(3) print(2)print(1)print(2)print(3) 이렇게 됨. 

### 3. [BOJ 14567 선수 과목](https://www.acmicpc.net/problem/14567) (강현지)

- **주제:** 위상정렬 개념 및 문제 풀이 설명
- **내용:** 라면 끓이는 과정을 통해 DAG와 위상정렬에 대한 개념 설명
- 진입 차수, 인접 리스트를 설명하며 선수 과목 문제 풀이 설명

### 4. [BOJ 2667 단지 번호 붙이기](https://www.acmicpc.net/problem/2667) (홍유라)

- **주제:** 단지 번호 붙이기의 bfs 풀이, dfs 풀이
- **내용:** queue를 사용하는 bfs, stack/재귀를 사용하는 dfs의 동작 과정 질문 및 이해

### 4. 큐 카드 2 문제 수학적 규칙으로 풀이하기 (박성은)

- **주제:** 도전 문제의 다른 풀이 방법 설명
- **내용:** 수학적 규칙 찾고 로직화하기

<details>
  <summary>상세 설명</summary>
 T = int(input())
for t in range(1, T+1):
    N = int(input())
    if N == 1:  # N이 1 인경우에는 예외가 없다 그러므로 1 (규칙성있는 수열에서 빠지기) 
        answer = 1
    else:
        k= 1
        while k * 2 <= N:
            k *= 2
        if N == k:
            answer = N 
        else:
            answer = (N - k) * 2
    print(f"#{t} {answer}")

k 는 '현재 인원수(N) 보다 작거나 같으면서 가장 큰 2의 거듭제곱 수' 이다. 
즉 게임의 규칙이 초기화 되는 기준점이다. 
 만약 기준점에 맞게 된다면 N 이 답이 되게 되고 
아니라면 (N-k)*2 가 되게 된다 . 

[N = 4 ~ 8까지 작동 과정]
핵심 규칙: k는 $N$보다 작거나 같은 가장 큰 2의 거듭제곱입니다. 
이 k를 기준으로 $N$이 얼마나 커졌느냐($N-k$)에 따라 생존자 번호가 결정됩니다.

1. N = 4 (기준점 k = 4)
k 찾기: $1 \to 2 \to 4$ (8은 4보다 크므로 $k=4$에서 멈춤)
상태: $N$이 정확히 2의 거듭제곱($k$)인 경우입니다.
계산: if N == k: 조건에 걸려 answer = 4가 됩니다.
의미: 인원이 2의 거듭제곱이면 마지막 번호(또는 1번)가 생존합니다.

2. N = 5 (기준점 k = 4)
k 찾기: $k=4$차이 
계산 ($N-k$): $5 - 4 = \mathbf{1}$ (기준보다 1명 많음)
계산: answer = 1 * 2 = 2의미: 1명이 제거되는 순간, 남은 4명 중 다음 차례인 2번이 새로운 시작점

3. N = 6 (기준점 k = 4)
k 찾기: $k=4$차이 
계산 ($N-k$): $6 - 4 = \mathbf{2}$ (기준보다 2명 많음)
계산: answer = 2 * 2 = 4
의미: 2명이 제거되는 순간, 남은 4명 중 다음 차례인 4번이 새로운 시작점

4. N = 7 (기준점 k = 4)
k 찾기: $k=4$차이 
계산 ($N-k$): $7 - 4 = \mathbf{3}$ (기준보다 3명 많음)
계산: answer = 3 * 2 = 6
의미: 3명이 제거되는 순간, 남은 4명 중 다음 차례인 6번이 새로운 시작점

5. N = 8 (새로운 기준점 k = 8)
k 찾기: $1 \to 2 \to 4 \to 8$ (16은 8보다 크므로 $k=8$에서 멈춤)
상태: 다시 $N$이 정확히 2의 거듭제곱($k$).
계산: if N == k: 조건에 걸려 answer = 8
의미: 다시 기준점이 8로 갱신되면서 규칙이 초기화

:bulb: 요약하자면
k의 의미: "가장 최근에 규칙이 1번(혹은 N번)으로 돌아갔던 인원수"
N - k의 의미: "기준점보다 추가된 인원수" → 이 인원만큼 순서가 2칸씩 뒤로 밀림.
k = 1로 시작하는 이유: 2의 거듭제곱($2, 4, 8, 16 \dots$)을 1부터 차례대로 곱해가며 $N$ 바로 직전의 기준점을 찾기 위함

이거는 수열의 N 을 늘려가며 테스트 해보면 보이는 수열의 규칙이다. 
while k * 2 <= N: k *= 2: $k$에 계속 2를 곱해가며 $N$을 넘지 않는 최대의 $2^n$ 값을 찾아내기N 이 4일때 부터 8일때까지 비교해보면 

N = 7
k = 1
while k * 2 <= 7: # 1*2, 2*2 까지는 실행되지만 4*2는 7보다 크므로 멈춤
    k *= 2        # k는 결국 4가 됨
</details>

<br/>

## 📌 다음 스터디

- **다음 주 도전 문제:** <img src='https://static.solved.ac/tier_small/11.svg' height='20px'/> [#5430 AC](https://www.acmicpc.net/problem/5430)
- **공지사항:** 3/3(화) 오프라인 스터디 예정

<br/>
